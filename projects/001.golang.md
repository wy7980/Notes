
## resources

|id|resources|link|
|--|---------|-----|
|1|[Go语言高级编程(Advanced Go Programming)](https://chai2010.cn/advanced-go-programming-book)|https://chai2010.cn/advanced-go-programming-book/|
|2|[Go 语言设计与实现](https://draveness.me/golang/)|https://draveness.me/golang/|
|3|[基础入门](https://www.kancloud.cn/liupengjie/go/570004)|https://www.kancloud.cn/liupengjie/go/570004|


## Notes

- [1.继承 & 接口](#head1)
	- [ 1.1.继承](#head2)
	- [ 1.2.接口](#head3)
	- [ 1.3.实现灵活的虚基类功能](#head4)
- [ 2.语言扩展](#head5)
	- [2.1.C语言扩展 cgo](#head6)
	- [2.2.Python语言扩展 go-python](#head7)
- [ 3.RPC](#head8)
- [ 4.数据库](#head9)
- [ 5.配置文件读取](#head10)
- [ 6.WEB相关](#head11)


## <span id="head1">1.继承 & 接口</span>
### <span id="head2"> 1.1.继承</span>

golang中没有真正意义上的继承，而是通过组合替代继承。

示例：
```
package main

import (
	"fmt"
)

//base class
type Animal struct{
	Name	string
}
func (ani Animal)GetName() string {
	return ani.Name
}
func (ani *Animal)SetName(name string) {
	ani.Name = name
}

//child class
type Dog struct {
	Animal
}

type Cat struct {
	Animal
}

func main() {
	tom := Dog{Animal{Name: "Tom"}}
	fmt.Println(tom.GetName())
	jary := Cat{Animal{Name: "Jary"}}
	fmt.Println(jary.GetName())
}

```
存在的问题：当我们想实现如下类似的功能时会发现不符合语法要求：
```
func main() {
	tom := Dog{Animal{Name: "Tom"}}
	fmt.Println(tom.GetName())
	jary := Cat{Animal{Name: "Jary"}}
	fmt.Println(jary.GetName())
	
	var anis []Animal
	anis = append(anis, tom) //error
	anis = append(anis, jary) //error
}
```
提示：
```
./prog.go:34:15: cannot use tom (type Dog) as type Animal in append
./prog.go:35:15: cannot use jary (type Cat) as type Animal in append
```

但是，如果使用接口类型作为基类就可以实现将派生类添加到基类数组的功能。

### <span id="head3"> 1.2.接口</span>
```
package main

import (
	"fmt"
)


type Animal interface{
	GetName()	string
}



//child class
type Dog struct {
	Name string
}
func (ani Dog)GetName() string {
	return ani.Name
}

type Cat struct {
	Name string
}
func (ani Cat)GetName() string {
	return ani.Name
}

func main() {
	tom := Dog{"Tom"}
	jary := Cat{"Jary"}

	var anis []Animal
	anis = append(anis, tom)
	anis = append(anis, jary)

	for _,ani := range anis {
		fmt.Println(ani.GetName())
	}
	
}
```

然而，虚基类的功实现了但是没法通过基类实现公共的函数，比如GetName()函数和成员Name可以放到基类给所有派生类公用，但是这里由于interface不能有成员变量，如果基类使用的是struct而不是interface如1.1又不能实现类似虚基类。

这里，我们可以使用struct和interface组合使用的方法来解决这个问题。

### <span id="head4"> 1.3.实现灵活的虚基类功能</span>
```
package main

import (
	"fmt"
)


type Animal interface{
	GetName()	string
}

type Base struct {
	Name	string
}
func (b Base)GetName() string {
	return b.Name
}

//child class
type Dog struct {
	Base
}


type Cat struct {
	Base
}


func main() {
	tom := Dog{Base{"Tom"}}
	jary := Cat{Base{"Jary"}}

	var anis []Animal
	anis = append(anis, tom)
	anis = append(anis, jary)

	for _,ani := range anis {
		fmt.Println(ani.GetName())
	}
	
}
```
这样不需要每个子类都定义成员Name和方法GetName().

---
**进一步提升**

如果要增加一个set方法呢？由于struct的方法如果传值，是无法保存到对象中的，所以需要定义一个如下函数：
```
package main

import (
	"fmt"
)


type Animal interface{
	GetName()	string
	SetName(string)
}

type Base struct {
	Name	string
}
func (b Base)GetName() string {
	return b.Name
}

func (b* Base)SetName(name string) {
	b.Name = name
}

//child class
type Dog struct {
	Base
}


type Cat struct {
	Base
}


func main() {
	tom := Dog{Base{"Tom"}}
	jary := Cat{Base{"Jary"}}

	var anis []Animal
	anis = append(anis, tom) //error
	anis = append(anis, jary) //error

	anis[0].SetName("new tom")
	
	for _,ani := range anis {
		fmt.Println(ani.GetName())
	}
	
}
```

但是又会有新的报错：
```
./prog.go:40:15: cannot use tom (type Dog) as type Animal in append:
	Dog does not implement Animal (SetName method has pointer receiver)
./prog.go:41:15: cannot use jary (type Cat) as type Animal in append:
	Cat does not implement Animal (SetName method has pointer receiver)
```

根据错误提示，append的时候Dog没有实现Animal,原因是有一个指针接收的SetName()方法，这是为什么呢？

这里涉及到一个Golang 中方法的集合的概念，一个struct虽然可以通过值类型和引用类型两种方式定义方法，但是不同的对象类型对应了不同的方法集：
```
Values                    Methods Receivers
-----------------------------------------------
 T                        (t T)
*T                        (t T) and (t *T) 
```
也就意味着，要想接收`func (b* Base)SetName(name string)`那么需要append传递到数组的是指针类型，不是值类型，解决方法便是在append时候传指针：
```
func main() {
	tom := Dog{Base{"Tom"}}
	jary := Cat{Base{"Jary"}}

	var anis []Animal
	anis = append(anis, &tom) //ok
	anis = append(anis, &jary) //ok

	anis[0].SetName("new tom")
	
	for _,ani := range anis {
		fmt.Println(ani.GetName())
	}
	
}
```

## <span id="head5"> 2.语言扩展</span>
### <span id="head6">2.1.C语言扩展 cgo</span>
使用golang自带的cgo可以实现go对C语言的调用，示例：
```
package main

/*
#include <stdio.h>

void printint(int v) {
    printf("printint: %d\n", v);
}
*/
import "C"

func main() {
    v := 123
    C.printint(C.int(v))
}
```

如果需要使用编译链接参数也可以通过注释指定：
```
// #cgo CFLAGS: -I./include
// #cgo LDFLAGS: -L/usr/local/lib -lxxx
// #include <xxx.h>
import "C"
```

注意：通过cgo调用C语言函数时参数类型转换，将go的类型转为cgo的。

如果是指针可以通过`unsafe.Pointer`转换，例如下面的代码对于一个uint32的参数gsip要转换成cgo的`* uint8_t`可以通过下面的方法：
```
tmp_sip := C.uint32_t(gsip)
sip_ptr := (*C.uint8_t)(unsafe.Pointer(&tmp_sip))
```

[]byte类型转成c的数组类型：
```
tcp_payload []byte
(*C.uint8_t)(unsafe.Pointer(&tcp_payload[0]))
```

### <span id="head7">2.2.Python语言扩展 go-python</span>

由于cgo可以调用c，c可以调用python，所以也可以直接用cgo调用python但是会比较麻烦，这里使用golang的go-python库实现python的调用。
安装依赖：
```
go get github.com/sbinet/go-python
```

python代码：
```
# fib.py
def fib(n):
    if n <= 2:
        return 1
    return fib(n-1) + fib(n-2)
```

调用示例：
```
package main

import (
	"fmt"

	"github.com/sbinet/go-python"
)

func init() {
	err := python.Initialize()
	if err != nil {
		panic(err.Error())
	}
}

func main() {
	m := python.PyImport_ImportModule("sys")
	if m == nil {
		fmt.Println("import error")
		return
	}
	path := m.GetAttrString("path")
	if path == nil {
		fmt.Println("get path error")
		return
	}
	//加入当前目录，空串表示当前目录
	currentDir := python.PyString_FromString("")
	python.PyList_Insert(path, 0, currentDir)

	m = python.PyImport_ImportModule("fib")
	if m == nil {
		fmt.Println("import error")
		return
	}
	fib := m.GetAttrString("fib")
	if fib == nil {
		fmt.Println("get fib error")
		return
	}
	out := fib.CallFunction(python.PyInt_FromLong(10))
	if out == nil {
		fmt.Println("call fib error")
		return
	}
        fmt.Printf("fib(%d)=%d\n", 10, python.PyInt_AsLong(out))
}
```


## <span id="head8"> 3.RPC</span>

## <span id="head9"> 4.数据库</span>

## <span id="head10"> 5.配置文件读取</span>

## <span id="head11"> 6.WEB相关</span>
