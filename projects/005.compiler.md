# 1.resources

* [哈工大《编译原理》视频教程](https://www.bilibili.com/video/av17649289?p=7)
* [LLVM官网资料(实现一个编译器demo)](http://llvm.org/docs/tutorial/)

# 2.tools
**golang**

* goyacc: golang yacc tool
* example: https://github.com/z-rui/interp2 使用golang自带的scanner做词法分析
* example: https://github.com/golang/tools/blob/master/cmd/goyacc/testdata/expr/expr.y
* golang自带词法分析：https://github.com/golang/go/tree/master/src/text/scanner


**python**

* ply: python lex-yacc https://www.dabeaz.com/ply/ply.html. 
* example: https://www.dabeaz.com/ply/example.html
* [《python Lex Yacc 手册》](https://www.kancloud.cn/kancloud/ply/42113)

# Notes

以下笔记基于[哈工大《编译原理》视频教程](https://www.bilibili.com/video/av17649289?p=7)。

- [1.resources](#1resources)
- [2.tools](#2tools)
- [Notes](#notes)
  - [1.语法分析](#1语法分析)
    - [1.0.基本概念相关](#10基本概念相关)
      - [1.0.0.文法](#100文法)
      - [1.0.1.分析树](#101分析树)
      - [1.0.2.自顶向下](#102自顶向下)
      - [1.0.3.自底向上](#103自底向上)
      - [1.0.4.左递归](#104左递归)
      - [1.0.5.LL(k)和LR(k)](#105llk和lrk)
    - [1.1.自顶向下语法分析](#11自顶向下语法分析)
      - [1.1.1.最左推导](#111最左推导)
      - [1.1.2.最右推导](#112最右推导)
      - [1.1.3.消除左递归](#113消除左递归)
      - [1.1.4.构建预测分析表](#114构建预测分析表)
      - [1.1.5.递归下降分析](#115递归下降分析)
      - [1.1.6.递归和非递归的预测分析法](#116递归和非递归的预测分析法)
    - [1.2.自底向上语法分析](#12自底向上语法分析)
      - [1.2.1.LR分析法](#121lr分析法)
      - [1.2.2.使用LR分析表分析](#122使用lr分析表分析)
      - [1.2.3.构造LR分析表](#123构造lr分析表)
      - [1.2.4.SLR分析法](#124slr分析法)
      - [1.2.5.LR(1)分析](#125lr1分析)
      - [1.2.6.LALR分析法](#126lalr分析法)
      - [1.2.7.二义性文法LR分析](#127二义性文法lr分析)
      - [1.2.8.LR分析中的错误处理](#128lr分析中的错误处理)

## 1.语法分析

### 1.0.基本概念相关
#### 1.0.0.文法
文法的形式化定义：
* N 有限个非终结符的集合；
* Σ 有限个终结符的集合；
* P 有限个生产规则(产生式)的集合；
* S 非终结符集合中唯一的开始符号；
  
文法被定义成一个四元组(N, Σ, P, S)，产生式的示例：

* A -> aAb
* A -> ab
* A -> ε
  
ε表示为空，由此可以产生出`ab`, `aabb`, `aaa..bbb`等字符串。


#### 1.0.1.分析树

以下面的文法和输入为例：
文法：
```
E-> E + E
E-> E * E
E-> (E)
E-> id
```
输入：
```
id + (id + id)
```

对应的分析树：
```
        E
       / \
      E + E
      |   /|\
      id ( E )
          /|\
        E  +  E
        |     |
        id    id
```

#### 1.0.2.自顶向下
自顶向下也就是按照从分析树的**根节点向叶节点**的方向，即从顶部向底部构造分析树。

#### 1.0.3.自底向上
与自顶向下相反，自底向上也就是按照从分析树的**叶节点向根节点**的方向，即从底部向根部构造分析树。

#### 1.0.4.左递归
左递归文法示例：
```
E -> E + T
  -> E + T + T
  -> E + T + T + T
  -> ...
```
像上面这种含有 A->Aα 形式产生式的文法称为是直接左递归的(immediate left recursive).

若一个非终结符号（non-terminal） A 有任何直接的文法规则或者透过多个文法规则，推导出的句型（sentential form）其中最左边的符号又会出现 A ，则我们说这个非终结符号 A 是左递归的。

经过两步或者两步以上推导产生的左递归称为是间接左递归的。

#### 1.0.5.LL(k)和LR(k)
LL(k)/LR(k)
* 中第一个字母L表示对输入的扫描的方向是从左到右扫描；
* 第二个字母L最左推导，R表示反向构造出一个最右推导序列；
* (k)表示分析时向前看k个输入符号；

当k=0时，可以省略(0)直接写成LL/LR。

### 1.1.自顶向下语法分析
从分析树的根节点向叶节点方向构造分析树。

#### 1.1.1.最左推导

**原则：**总是选择每个句型中的**最左非终结符**进行替换。
例如上面的文法和输入，使用最左推导过程如下：
```
E -> E + E
  -> id + E
  -> id + (E)
  -> id + (E + E)
  -> id + (id + E)
  -> id + (id + id)
```
上面的过程从上往下叫做**最左推导**，反过来从下往上叫做**最右归约**。

**自顶向下的语法分析采用最左推导方式。**

#### 1.1.2.最右推导

**原则：**总是选择每个句型中的**最右非终结符**进行替换。
例如上面的文法和输入，使用最右推导过程如下：
```
E -> E + E
  -> E + (E)
  -> E + (E + E)
  -> E + (E + id)
  -> E + (id + id)
  -> id + id + id)
```

上面的过程从上往下叫做**最右推导**，反过来从下往上叫做**最左归约**。

在**自底向上**的分析中中，总是采用最左归约的方式，因此把**最左归约**成为**规范归约**，把**最右推导**称为**规范推导**。


#### 1.1.3.消除左递归
从前面说的左递归可以知道，左递归文法会使递归下降分析器陷入无限循环。

消除直接左递归：
* A -> Aα|β (注： α不为空，β不以A开头)
  
通过引入一些非终结符和空产生式。
* A -> β A'
* A' -> α A'|ε
  



消除间接左递归：

示例：
* S -> Aa|b
* A -> Ac|Sd|ε

将第一条文法带入第二条得到：
* A -> Ac|Aad|bd|ε

消除左递归：
* A -> bdA'
* A' -> cA'|adA'|ε

#### 1.1.4.构建预测分析表
* FIRST(A)集：可以从非终结符A推导出的所有**串首终结符**构成的集合。
  * 示例：
    * E->TE'
    * E'->+TE'|ε
    * T->FT'
    * T'->*FT'|ε
    * F->(E)|id

  * 推导出各项非终结符的FIRST集：
    * FIRST(E) = { (,  id }
    * FIRST(E') = {+, ε}
    * FIRST(T) = {(, id}
    * FIRST(T') = {*, ε}
    * FIRST(F) = {(, id}

* FOLLOW(A)集：可能在某个句型中**紧跟在非终结符A后面的终结符**a的集合。如果A是某个句型的最右符号，则将结束符"$"添加到FOLLOW(A)中。
  * 规则
    * 若A是开始符号，则$就在FOLLOW(A)中。
    * 若存在产生式B->α Aβ，则 FIRST(β)-{ε} 在FOLLOW(A)中。
    * 若存在产生式B->α Aβ，且 ε 在FIRST(β)中，则FOLLOW(A)包括FOLLOW(B)。
  * 示例：
    * E->TE'
    * E'->+TE'|ε
    * T->FT'
    * T'->*FT'|ε
    * F->(E)|id

  * 首先将\$加入开始符号E的FOLLOW集中，推导出各项非终结符的FOLLOW集：
    * FOLLOW(E) = {$, )}
    * FOLLOW(E') = {$, )}
    * FOLLOW(T) = {+, $, )}
    * FOLLOW(T') = {+, $, )}
    * FOLLOW(F) = {*, +, $, )}


* SELECT(A)集：
  * |X|FIRST(X)|FOLLOW(X)|
    |---|----|----|
    |E|( id|$ )|
    |E'|+ ε|$ )|
    |T|(, id|+ ) $|
    |T'|* ε|+ ) $|
    |F|( id|* + ) $|
  * 得到SELECT集：
    |产生式|SELECT|
    |------|------|
    |E->TE'|( id|
    |E'->+TE'|+|
    |E'->ε|$ )|
    |T->FT'|( id|
    |T'->*FT'|*|
    |T'->ε|+ ) $|
    |F->(E)|(|
    |F->id|id||
  上面的文法是LL(1)文法，**同一非终结符的各个产生式的可选集互不相交**。
* 预测分析表
  |X|产生式|SELECT|
  |----|----|---|
  |E  |E->TE'|( id|
  |E'  |E'->+TE'|+|
  |  |E'->ε|$ )|
  |T  |T->FT'|( id|
  |T'  |T'->*FT'|*|
  |F  |F->(E)|(|
  | |F->id|id|

#### 1.1.5.递归下降分析
递归下降分析法是确定的自上而下分析法，这种分析法要求文法是LL(1)文法。
* 为每个非终结符编制一个递归下降分析函数，每个函数名是相应的非终结符，函数体则是根据规则右部符号串的结构和顺序编写。
* 子程序相互递归调用。
  

对于以下左递归文法：
* E -> E + T | T
* T -> T * F | F
* F -> (E) | id
  
通过消除左递归得到下面的LL(1)文法：
* E -> TE'
* E' -> +TE'|ε
* T -> FT'
* T' -> *FT'|ε
* F -> (E)|id

构建递归下降分析程序：
```
//S
main() {
  scan();
  E();
  if (sym == '$'){
    printf("success")
  }else{
    printf("fail")
  }

}

//E
E(){
  T();
  E'();
}

//E'
E'(){
  if(sym == '+'){
    scan();
    T();
    E'();
  }else if((sym != ')' && (sym != '$')){
    error();
  }
}

//T
T(){
  F();
  T'();
}

//T'
T'(){
  if(sym == '*'){
    scan();
    F();
    T();

  }else if(sym not in FOLLOW(T'){
    error();
  })
}

//F
F(){
  if(sym =='id'){
    scan();
  }else if(sym == '('){
    scan();
    E();
    if(sym == ')'){
      scan();
    }else{
      error();
    }else{
      error();
    }
  }
}
```
FOLLOW(T') = {+ ) $}

* 优点：递归下降分析法简单、直观，易于构造分析程序。
* 缺点：对文法要求高，必须是LL(1)文法，同时由于递归调用较多，影响分析器的效率。

#### 1.1.6.递归和非递归的预测分析法
递归的预测分析法是指：在递归下降分析中，根据预测分析表进行产生式的选择。

非递归的预测分析法：也叫表驱动预测分析，不需要为每个非终结符编写递归下降过程，而是根据预测分析表构造一个自动机。

对比：
||递归的预测分析法|非递归的预测分析法|
|--|---|--|
|程序规模|程序规模较大，不需要载入分析表|主程序规模较小，需要载入分析表(表较小)|
|直观性|较好|较差|
|效率|较低|分析时间大约正比于待分析程序的长度|
|自动生成|较难|较易|

**总结**：LL文法相关知识点学习完了可以考虑手写一个递归下降的四则运算程序，这里我实现了一个详见笔记[手写递归下降](/projects/005.compiler-手写递归下降.md)，考虑四则运算文法不算复杂，可以考虑推导出预测分析表，基于预测分析表实现递归的预测分析，可以参考笔记[LL预测分析法](/projects/005.compiler-LL预测分析法.md)中的实例。


### 1.2.自底向上语法分析
* 从分析树的叶节点向根节点方向构造分析树。

* 可以看成是从输入串归约为文法开始符号S的过程。

* **自顶向下**的语法分析采用的**最左推导**

* **自底向上**的语法分析采用的**最左归约**，即反向构造最右推导。

自底向上语法分析采用的移进-归约分析(shift-reduce parsing)。

示例：
|栈|剩余输入|动作|
|--|--:|--|
|$|id + (id + id)$||
|$id|+ (id + id)$|移进|
|$E|+ (id + id)$|归约：E->id|
|$E +|(id + id)$|移进|
|$E +(|id + id)$|移进|
|$E + (id| + id)$|移进|
|$E + (E| + id)$|归约：E->id|
|$E + (E +| id)$|移进|
|$E + (E + id|)$|移进|
|$E + (E + E|)$|归约：E->id|
|$E + (E|)$|归约：E->E+E|
|$E + (E)|$|移进|
|$E + E|$|归约：E->(E)|
|$E|$|归约：E->E+E|

#### 1.2.1.LR分析法
LR文法是最大的、可以构造出相应移进-归约语法分析器的问法类。

* L：对输入从左到右扫描
* R：反向构造最右推导序列

LR(k)：预测分析时向前看k个符号。

#### 1.2.2.使用LR分析表分析
示例文法：
* S->BB
* B->aB
* B->b

该文法所对应的LR分析表：
|状态|ACTION|||GOTO||
|-|-|-|-|-|-|
||a|b|$|S|B|
|0|s3|s4||1|2|
|1|||acc|||
|2|s3|s4|||5|
|3|s3|s4|||6|
|4|r3|r3|r3|||
|5|r1|r1|r1|||
|6|r2|r2|r2|||

使用状态表分析基于三个部分：状态栈，符号栈，输入缓冲区。

分析表使用的是状态机的方式，
* 状态i：第一列状态0~6表示6种状态。
* ACTION 表：表中的元素都是**终结符**，表示当前状态下遇到的输入非终结符时应该做什么动作。
    * s表示shift即移进操作，si表示将当前输入非终结符移进符号栈，并且将状态i移入状态栈。
    * r表示是reduce即进行归约操作，ri表示按照第i条规则进行归约，根据规则i将符号栈和状态栈中的对应个数量的元素出栈，然后将归约后的元素移入符号栈。归约完后根据GOTO表进行跳转。
* GOTO 表：表中的元素都是**非终结符**，表示当前状态下，如果符号栈出现了对应的非终结符则进行相应的跳转动作，跳转到状态j，并且将状态j移入状态栈。

**注意**：
* 分析开始时的状态为状态0
* GOTO表是在执行完归约动作后查，其他情况查ACTION表。

以输入字符串bab和上面的分析表为例，完整的分析过程如下：
1. 初始状态为状态0，符号栈为\$，状态栈为0，输入缓冲区为bab\$。
2. 查ACTION表，根据第0行，当前状态为0，遇到缓冲区输入的终结符b对应表中s4，执行移进操作，将b移进符号栈，将4移入状态栈。此时状态栈：04，符号栈：\$b，输入缓冲区：ab\$。
3. 查ACTION表，当前状态栈顶为4号状态，查看表第4行，遇到输入缓冲区终结符a，执行r3归约，将符号栈中b出栈，将状态栈中4出栈，B->b将归约后的B移入符号栈。此时状态栈：0，符号栈：\$B，输入缓冲区：ab\$。
4. 上步为归约所以查GOTO表，当前状态栈顶为0号状态，符号栈顶为非终结符B，根据GOTO表跳转到状态2，即将2移进状态栈。此时状态栈：02，符号栈：\$B，输入缓冲区：ab\$。
5. 查ACTION表，当前状态栈顶为2号状态，遇到输入终结符a，执行s3，将符号a移进符号栈，状态3移进状态栈。此时状态栈：023，符号栈：\$Ba，输入缓冲区：b\$。
6. 查ACTION表，当前状态栈顶为3号状态，遇到输入终结符b，执行s4，将符号b移进符号栈，状态4移进状态栈。此时状态栈：0234，符号栈：\$Bab，输入缓冲区：\$。
7. 查ACTION表，当前状态栈顶为4号状态，遇到输入终结符\$，执行r3，按照规则B->b归约，将符号b移出符号栈，状态4移出状态栈，将符号B移入符号栈。此时状态栈：023，符号栈：\$BaB，输入缓冲区：\$。
8. 上步为归约所以查GOTO表，当前状态栈顶为3号状态，符号栈顶为非终结符B，根据GOTO表跳转到状态6，即将6移进状态栈。此时状态栈：0236，符号栈：\$BaB，输入缓冲区：\$。
9. 查ACTION表，当前状态栈顶为6号状态，遇到输入终结符\$，执行r2，按照规则B->aB归约，将符号aB移出符号栈，状态36移出状态栈，将符号B移入符号栈。此时状态栈：02，符号栈：\$BB，输入缓冲区：\$。
10. 上步为归约所以查GOTO表，当前状态栈顶为2号状态，符号栈顶为非终结符B，根据GOTO表跳转到状态5，即将5移进状态栈。此时状态栈：025，符号栈：\$BB，输入缓冲区：\$。
11. 查ACTION表，当前状态栈顶为5号状态，遇到输入终结符\$，执行r1，按照规则S->BB归约，将符号BB移出符号栈，状态25移出状态栈，将符号S移入符号栈。此时状态栈：0，符号栈：\$S，输入缓冲区：\$。
12. 上步为归约所以查GOTO表，当前状态栈顶为0号状态，符号栈顶为非终结符S，根据GOTO表跳转到状态1，即将1移进状态栈。此时状态栈：01，符号栈：\$S，输入缓冲区：\$。
13. 查ACTION表，当前状态栈顶为1号状态，遇到输入终结符\$，执行acc，即accept，接收成功。此时状态栈：0，符号栈：\$S，输入缓冲区：\$。

#### 1.2.3.构造LR分析表
**LR(0)项目**
* 定义：右部某位置标有圆点的产生式成为相应文法的一个LR(0)项目（简称项目）。
* 实例 S->bBB
  * s->.bBB 移进项目
  * s->b.BB 待约项目
  * s->bB.B 待约项目
  * s->bBB. 规约项目
* 作用：项目描述了句柄识别的状态
* 空产生式A->ε只生成一个项目 A->.

**增广文法(Augmented Grammar)**
* 定义：如果G是一个以S为开始符号的文法，则G的增广文法G'就是在G中加上新开始符号S'和产生式S'->S而得到的文法。
* 实例：
  ```
   1)E->E+T
   2)E->T
   3)T->T*F
   4)T->F
   5)F->(E)
   6)F->id
  ```
  引入E'，得到
  ```
   0)E'->E
   1)E->E+T
   2)E->T
   3)T->T*F
   4)T->F
   5)F->(E)
   6)F->id
  ```
  增广文法引入新产生式的目的：使得文法的开始符号仅出现在一个产生式的左边，从而使得分析器只有一个接受状态。

**文法中的项目**

根据每个文法写出该文法的所有的项目：
|S'->S|S->vI:T|I->I,i|I->i|T->r|
|-----|-------|------|-----|----|
||(2)S->.vI:T||||
||(3)S->v.I:T|(7)I->.I,i|||
||(4)S->vI.:T|(8)I->I.,i|||
|(0)S'->.S|(5)S->vI:.T|(9)I->I,.i|(11)I->.i|(13)T->.r|
|(1)S'->S.|(6)S->vI:T.|(10)I->I,i.|(12)I->i.|(14)T->r.|
可以把等价的项目组成一个项目集I，成为项目集闭包(Closure of Item Sets)，每个项目集闭包对应着自动机的一个状态。

**LR(0)自动机**

![](/projects/picture/005-LR(0)-automata.jpg)
* I0是初始状态，对应每个产生式中小圆点在开头的位置的LR(0)项目。
* I1对应I0中产生式S'->.S遇到S了以后进入到S->S.即I1。
* I2中包含了I0中文法1对应的S->.BB遇到B后进入S->B.B以及S->B.B的等价项目B->.aB和B->.b。
* 其他状态类似推导。

**移进/归约冲突**

![](/projects/picture/005-LR-shift-reduce-conflict-1.jpg)

从图中可以看到，状态2遇到*时，如果按照文法E->T则需要执行r2归约，如果按照T->T.*F则需要执行s7移进。

![](/projects/picture/005-LR-shift-reduce-conflict-2.jpg)

如果LR(0)分析表中没有语法分析动作冲突，那么给定的文法就称为LR(0)文法。

#### 1.2.4.SLR分析法
SLR可以一定程度解决上面的移进/归约冲突，对于已知项目集I：
```
//m个移进项目
A1->α1.a1β
A2->α2.a2β
...
Am->αm.amβ


//n个归约项目
B1->γ1.
B2->γ2.
...
Bn->γn.
```
如果集合{a1,a2,...,am}和FOLLOW(B1),Follow(B2),...,FOLLOW(Bn)**两两不相交**，则项目集I中的冲突可以按照下面的原则解决：
设a是下一个输入符号
* 若a属于{a1,a2,...,am}, 则移进a
* 若a属于FOLLOW(Bj)，则用产生式Bj->γj归约
* 此外，报错


#### 1.2.5.LR(1)分析
**SLR分析存在的问题:**

SLR只是简单地考察下一个输入符号b是否属于与归约项目A->α相关联的FOLLOW(A)，但是b属于FOLLOW(A)只是规约α的一个必要条件，而非充分条件。

**LR(1)分析法的提出:**
* 对于产生式A->α的归约，在不同的使用位置，A会要求不同的后继符号。
* 在特定位置，A的后继符集合是FOLLOW(A)的子集。

**规范LR(1)项目**
将一般形式为[A->α.β, a]的项称为LR(1)项，其中A->αβ是一个产生式，a是一个终结符(这里将$作为一个特殊的终结符)它表示在当前的状态下，A后面必须紧跟的终结符，称为该项的展望项(lookahead)。

* LR(1)中的1指的是项的第二个分量的长度
* 在形如[A->α.β, a]且β不为空产生式的项中，展望符a没有任何作用
* 形如[A->α., a]的项在只有下一个输入符号等于a时才可以按照A->α进行规约
  * 这样的a的集合总是FOLLOW(A)的子集，而且它通常是一个真子集。

**LR(1)自动机**
![](picture/005-LR(1)-automata-1.jpg)

![](picture/005-LR(1)-automata-2.jpg)

同心项目集：如果除展望符外，两个LR(1)项目集是相同的，则称这两个LR(1)项目集是同心的。见下图：
![](picture/005-LR(1)-automata-3.jpg)

#### 1.2.6.LALR分析法
* 基本思想
  * 寻找具有相同核心的LR(1)项集，并将这些项集合并为一个项集，所谓项集的核心就是其第一分量的集合
  * 然后根据合并得到的项集族构造语法分析表
  * 如果分析表中没有语法分析动作冲突，给定的文法就称为LALR(1)文法，就可以根据该分析表进行语法分析

* 示例
  * ![](picture/005-LR(1)-automata-4.jpg)
  注意：合并同心项集时产生归约-归约冲突，合并同心项集后虽然不产生冲突但可能会推迟错误的发现。

* LALR(1)的特点
  * 形式上与LR(1)相同
  * 大小上与LR(0)/SLR相当
  * 分析能力介于SLR和LR(1)二者之间 SLR < LALR(1) < LR(1)
  * 合并后的展望符集合仍为FOLLOW集的子集

#### 1.2.7.二义性文法LR分析
* 二义性文法的特点
  * 每个二义性文法都不是LR的
  * 某些类型的二义性文法在语言的描述和实现中很有用，更简短、更自然

* 二义性文法的使用
  * 应该保守地使用二义性文法，并且必须在严格控制下使用，因为稍有不慎就会导致语法分析器识别的语言出现偏差

#### 1.2.8.LR分析中的错误处理
略