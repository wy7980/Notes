# 1.resources

* [哈工大《编译原理》视频教程](https://www.bilibili.com/video/av17649289?p=7)
* [LLVM官网资料(实现一个编译器demo)](http://llvm.org/docs/tutorial/)

# 2.tools
**golang**

* goyacc: golang yacc tool
* example: https://github.com/z-rui/interp2 使用golang自带的scanner做词法分析
* example: https://github.com/golang/tools/blob/master/cmd/goyacc/testdata/expr/expr.y
* golang自带词法分析：https://github.com/golang/go/tree/master/src/text/scanner


**python**

* ply: python lex-yacc https://www.dabeaz.com/ply/ply.html. 
* example: https://www.dabeaz.com/ply/example.html
* [《python Lex Yacc 手册》](https://www.kancloud.cn/kancloud/ply/42113)

# Notes

以下笔记基于[哈工大《编译原理》视频教程](https://www.bilibili.com/video/av17649289?p=7)。

- [1.resources](#1resources)
- [2.tools](#2tools)
- [Notes](#notes)
  - [1.语法分析](#1语法分析)
    - [1.0.基本概念相关](#10基本概念相关)
      - [1.0.0.文法](#100文法)
      - [1.0.1.分析树](#101分析树)
      - [1.0.2.自顶向下](#102自顶向下)
      - [1.0.3.自底向上](#103自底向上)
      - [1.0.4.左递归](#104左递归)
      - [1.0.5.LL(k)和LR(k)](#105llk和lrk)
    - [1.1.自顶向下语法分析](#11自顶向下语法分析)
      - [1.1.1.最左推导](#111最左推导)
      - [1.1.2.最右推导](#112最右推导)
      - [1.1.3.消除左递归](#113消除左递归)
      - [1.1.4.构建预测分析表](#114构建预测分析表)
      - [1.1.5.递归下降分析](#115递归下降分析)
      - [1.1.6.递归和非递归的预测分析法](#116递归和非递归的预测分析法)
    - [1.2.自底向上语法分析](#12自底向上语法分析)
      - [1.2.1.LR分析法](#121lr分析法)
      - [1.2.2.使用LR分析表分析](#122使用lr分析表分析)
      - [1.2.3.LALR分析法](#123lalr分析法)
      - [1.2.4.二义性文法LR分析](#124二义性文法lr分析)

## 1.语法分析

### 1.0.基本概念相关
#### 1.0.0.文法
文法的形式化定义：
* $N$ 有限个非终结符的集合；
* $\Sigma$ 有限个终结符的集合；
* $P$ 有限个生产规则(产生式)的集合；
* $S$ 非终结符集合中唯一的开始符号；
  
文法被定义成一个四元组$(N, \Sigma, P, S)$，产生式的示例：

* $A -> aAb$
* $A -> ab$
* $A -> \epsilon$
  
$\epsilon$表示为空，由此可以产生出`ab`, `aabb`, `aaa..bbb`等字符串。


#### 1.0.1.分析树

以下面的文法和输入为例：
文法：
```
E-> E + E
E-> E * E
E-> (E)
E-> id
```
输入：
```
id + (id + id)
```

对应的分析树：
```
        E
       / \
      E + E
      |   /|\
      id ( E )
          /|\
        E  +  E
        |     |
        id    id
```

#### 1.0.2.自顶向下
自顶向下也就是按照从分析树的**根节点向叶节点**的方向，即从顶部向底部构造分析树。

#### 1.0.3.自底向上
与自顶向下相反，自底向上也就是按照从分析树的**叶节点向根节点**的方向，即从底部向根部构造分析树。

#### 1.0.4.左递归
左递归文法示例：
```
E -> E + T
  -> E + T + T
  -> E + T + T + T
  -> ...
```
像上面这种含有 A->A$\alpha$ 形式产生式的文法称为是直接左递归的(immediate left recursive).

若一个非终结符号（non-terminal） A 有任何直接的文法规则或者透过多个文法规则，推导出的句型（sentential form）其中最左边的符号又会出现 A ，则我们说这个非终结符号 A 是左递归的。

经过两步或者两步以上推导产生的左递归称为是间接左递归的。

#### 1.0.5.LL(k)和LR(k)
LL(k)/LR(k)
* 中第一个字母L表示对输入的扫描的方向是从左到右扫描；
* 第二个字母L最左推导，R表示反向构造出一个最右推导序列；
* (k)表示分析时向前看k个输入符号；

当k=0时，可以省略(0)直接写成LL/LR。

### 1.1.自顶向下语法分析
从分析树的根节点向叶节点方向构造分析树。

#### 1.1.1.最左推导

**原则：**总是选择每个句型中的**最左非终结符**进行替换。
例如上面的文法和输入，使用最左推导过程如下：
```
E -> E + E
  -> id + E
  -> id + (E)
  -> id + (E + E)
  -> id + (id + E)
  -> id + (id + id)
```
上面的过程从上往下叫做**最左推导**，反过来从下往上叫做**最右归约**。

**自顶向下的语法分析采用最左推导方式。**

#### 1.1.2.最右推导

**原则：**总是选择每个句型中的**最右非终结符**进行替换。
例如上面的文法和输入，使用最右推导过程如下：
```
E -> E + E
  -> E + (E)
  -> E + (E + E)
  -> E + (E + id)
  -> E + (id + id)
  -> id + id + id)
```

上面的过程从上往下叫做**最右推导**，反过来从下往上叫做**最左归约**。

在**自底向上**的分析中中，总是采用最左归约的方式，因此把**最左归约**成为**规范归约**，把**最右推导**称为**规范推导**。


#### 1.1.3.消除左递归
从前面说的左递归可以知道，左递归文法会使递归下降分析器陷入无限循环。

消除直接左递归：
* $A -> A\alpha|\beta$ (注： $\alpha$不为空，$\beta$不以$A$开头)
  
通过引入一些非终结符和空产生式。
* $A -> \beta A'$
* $A' -> \alpha A'|\epsilon$
  



消除间接左递归：

示例：
* $S -> Aa|b$
* $A -> Ac|Sd|\epsilon$

将第一条文法带入第二条得到：
* $A -> Ac|Aad|bd|\epsilon$

消除左递归：
* $A -> bdA'$
* $A' -> cA'|adA'|\epsilon$

#### 1.1.4.构建预测分析表
* FIRST(A)集：可以从非终结符A推导出的所有**串首终结符**构成的集合。
  * 示例：
    * $E->TE'$
    * $E'->+TE'|\epsilon$
    * $T->FT'$
    * $T'->*FT'|\epsilon$
    * $F->(E)|id$

  * 推导出各项非终结符的FIRST集：
    * $FIRST(E) = \{ (,  id \}$
    * $FIRST(E') = \{+, \epsilon\}$
    * $FIRST(T) = \{(, id\}$
    * $FIRST(T') = \{*, \epsilon\}$
    * $FIRST(F) = \{(, id\}$

* FOLLOW(A)集：可能在某个句型中**紧跟在非终结符A后面的终结符**a的集合。如果A是某个句型的最右符号，则将结束符"$"添加到FOLLOW(A)中。
  * 规则
    * 若A是开始符号，则$就在FOLLOW(A)中。
    * 若存在产生式$B->\alpha A\beta$，则 $FIRST(\beta)-\{\epsilon\}$ 在FOLLOW(A)中。
    * 若存在产生式$B->\alpha A\beta$，且 $\epsilon$ 在$FIRST(\beta)$中，则FOLLOW(A)包括FOLLOW(B)。
  * 示例：
    * $E->TE'$
    * $E'->+TE'|\epsilon$
    * $T->FT'$
    * $T'->*FT'|\epsilon$
    * $F->(E)|id$

  * 首先将\$加入开始符号E的FOLLOW集中，推导出各项非终结符的FOLLOW集：
    * $FOLLOW(E) = \{\$, )\}$
    * $FOLLOW(E') = \{\$, )\}$
    * $FOLLOW(T) = \{+, \$, )\}$
    * $FOLLOW(T') = \{+, \$, )\}$
    * $FOLLOW(F) = \{*, +, \$, )\}$


* SELECT(A)集：
  * |X|FIRST(X)|FOLLOW(X)|
    |---|----|----|
    |E|( id|$ )|
    |E'|+ $\epsilon$|$ )|
    |T|(, id|+ ) $|
    |T'|* $\epsilon$|+ ) $|
    |F|( id|* + ) $|
  * 得到SELECT集：
    |产生式|SELECT|
    |------|------|
    |E->TE'|( id|
    |E'->+TE'|+|
    |E'->$\epsilon$|$ )|
    |T->FT'|( id|
    |T'->*FT'|*|
    |T'->$\epsilon$|+ ) $|
    |F->(E)|(|
    |F->id|id|
    上面的文法是LL(1)文法，**同一非终结符的各个产生式的可选集互不相交**。
* 预测分析表
  |X|产生式|SELECT|
  |----|----|---|
  |E  |E->TE'|( id|
  |E'  |E'->+TE'|+|
  |  |E'->$\epsilon$|$ )|
  |T  |T->FT'|( id|
  |T'  |T'->*FT'|*|
  |F  |F->(E)|(|
  | |F->id|id|

#### 1.1.5.递归下降分析
递归下降分析法是确定的自上而下分析法，这种分析法要求文法是LL(1)文法。
* 为每个非终结符编制一个递归下降分析函数，每个函数名是相应的非终结符，函数体则是根据规则右部符号串的结构和顺序编写。
* 子程序相互递归调用。
  

对于以下左递归文法：
* E -> E + T | T
* T -> T * F | F
* F -> (E) | id
  
通过消除左递归得到下面的LL(1)文法：
* $E -> TE'$
* $E' -> +TE'|\epsilon$
* $T -> FT'$
* $T' -> *FT'|\epsilon$
* $F -> (E)|id$
构建递归下降分析程序：
```
//S
main() {
  scan();
  E();
  if (sym == '$'){
    printf("success")
  }else{
    printf("fail")
  }

}

//E
E(){
  T();
  E'();
}

//E'
E'(){
  if(sym == '+'){
    scan();
    T();
    E'();
  }else if((sym != ')' && (sym != '$')){
    error();
  }
}

//T
T(){
  F();
  T'();
}

//T'
T'(){
  if(sym == '*'){
    scan();
    F();
    T();

  }else if(sym not in FOLLOW(T'){
    error();
  })
}

//F
F(){
  if(sym =='id'){
    scan();
  }else if(sym == '('){
    scan();
    E();
    if(sym == ')'){
      scan();
    }else{
      error();
    }else{
      error();
    }
  }
}
```
FOLLOW(T') = {+ ) $}

* 优点：递归下降分析法简单、直观，易于构造分析程序。
* 缺点：对文法要求高，必须是LL(1)文法，同时由于递归调用较多，影响分析器的效率。

#### 1.1.6.递归和非递归的预测分析法
递归的预测分析法是指：在递归下降分析中，根据预测分析表进行产生式的选择。

非递归的预测分析法：也叫表驱动预测分析，不需要为每个非终结符编写递归下降过程，而是根据预测分析表构造一个自动机。

对比：
||递归的预测分析法|非递归的预测分析法|
|--|---|--|
|程序规模|程序规模较大，不需要载入分析表|主程序规模较小，需要载入分析表(表较小)|
|直观性|较好|较差|
|效率|较低|分析时间大约正比于待分析程序的长度|
|自动生成|较难|较易|

**总结**：LL文法相关知识点学习完了可以考虑手写一个递归下降的四则运算程序，这里我实现了一个详见笔记[手写递归下降](/projects/005.compiler-手写递归下降.md)，考虑四则运算文法不算复杂，可以考虑推导出预测分析表，基于预测分析表实现递归的预测分析。


### 1.2.自底向上语法分析
* 从分析树的叶节点向根节点方向构造分析树。

* 可以看成是从输入串归约为文法开始符号S的过程。

* **自顶向下**的语法分析采用的**最左推导**

* **自底向上**的语法分析采用的**最左归约**，即反向构造最右推导。

自底向上语法分析采用的移进-归约分析(shift-reduce parsing)。

示例：
|栈|剩余输入|动作|
|--|--:|--|
|$|id + (id + id)$||
|$id|+ (id + id)$|移进|
|$E|+ (id + id)$|归约：E->id|
|$E +|(id + id)$|移进|
|$E +(|id + id)$|移进|
|$E + (id| + id)$|移进|
|$E + (E| + id)$|归约：E->id|
|$E + (E +| id)$|移进|
|$E + (E + id|)$|移进|
|$E + (E + E|)$|归约：E->id|
|$E + (E|)$|归约：E->E+E|
|$E + (E)|$|移进|
|$E + E|$|归约：E->(E)|
|$E|$|归约：E->E+E|

#### 1.2.1.LR分析法
LR文法是最大的、可以构造出相应移进-归约语法分析器的问法类。

* L：对输入从左到右扫描
* R：反向构造最右推导序列

LR(k)：预测分析时向前看k个符号。

#### 1.2.2.使用LR分析表分析
示例文法：
* $S->BB$
* $B->aB$
* $B->b$

该文法所对应的LR分析表：
|状态|ACTION|||GOTO||
|-|-|-|-|-|-|
||a|b|$|S|B|
|0|s3|s4||1|2|
|1|||acc|||
|2|s3|s4|||5|
|3|s3|s4|||6|
|4|r3|r3|r3|||
|5|r1|r1|r1|||
|6|r2|r2|r2|||

使用状态表分析基于三个部分：状态栈，符号栈，输入缓冲区。

分析表使用的是状态机的方式，
* 状态i：第一列状态0~6表示6种状态。
* ACTION 表：表中的元素都是**终结符**，表示当前状态下遇到的输入非终结符时应该做什么动作。
    * s表示shift即移进操作，si表示将当前输入非终结符移进符号栈，并且将状态i移入状态栈。
    * r表示是reduce即进行归约操作，ri表示按照第i条规则进行归约，根据规则i将符号栈和状态栈中的对应个数量的元素出栈，然后将归约后的元素移入符号栈。归约完后根据GOTO表进行跳转。
* GOTO 表：表中的元素都是**非终结符**，表示当前状态下，如果符号栈出现了对应的非终结符则进行相应的跳转动作，跳转到状态j，并且将状态j移入状态栈。

**注意**：
* 分析开始时的状态为状态0
* GOTO表是在执行完归约动作后查，其他情况查ACTION表。

以输入字符串bab和上面的分析表为例，完整的分析过程如下：
1. 初始状态为状态0，符号栈为\$，状态栈为0，输入缓冲区为bab\$。
2. 查ACTION表，根据第0行，当前状态为0，遇到缓冲区输入的终结符b对应表中s4，执行移进操作，将b移进符号栈，将4移入状态栈。此时状态栈：04，符号栈：\$b，输入缓冲区：ab\$。
3. 查ACTION表，当前状态栈顶为4号状态，查看表第4行，遇到输入缓冲区终结符a，执行r3归约，将符号栈中b出栈，将状态栈中4出栈，$B->b$将归约后的B移入符号栈。此时状态栈：0，符号栈：\$B，输入缓冲区：ab\$。
4. 上步为归约所以查GOTO表，当前状态栈顶为0号状态，符号栈顶为非终结符B，根据GOTO表跳转到状态2，即将2移进状态栈。此时状态栈：02，符号栈：\$B，输入缓冲区：ab\$。
5. 查ACTION表，当前状态栈顶为2号状态，遇到输入终结符a，执行s3，将符号a移进符号栈，状态3移进状态栈。此时状态栈：023，符号栈：\$Ba，输入缓冲区：b\$。
6. 查ACTION表，当前状态栈顶为3号状态，遇到输入终结符b，执行s4，将符号b移进符号栈，状态4移进状态栈。此时状态栈：0234，符号栈：\$Bab，输入缓冲区：\$。
7. 查ACTION表，当前状态栈顶为4号状态，遇到输入终结符\$，执行r3，按照规则$B->b$归约，将符号b移出符号栈，状态4移出状态栈，将符号B移入符号栈。此时状态栈：023，符号栈：\$BaB，输入缓冲区：\$。
8. 上步为归约所以查GOTO表，当前状态栈顶为3号状态，符号栈顶为非终结符B，根据GOTO表跳转到状态6，即将6移进状态栈。此时状态栈：0236，符号栈：\$BaB，输入缓冲区：\$。
9. 查ACTION表，当前状态栈顶为6号状态，遇到输入终结符\$，执行r2，按照规则$B->aB$归约，将符号aB移出符号栈，状态36移出状态栈，将符号B移入符号栈。此时状态栈：02，符号栈：\$BB，输入缓冲区：\$。
10. 上步为归约所以查GOTO表，当前状态栈顶为2号状态，符号栈顶为非终结符B，根据GOTO表跳转到状态5，即将5移进状态栈。此时状态栈：025，符号栈：\$BB，输入缓冲区：\$。
11. 查ACTION表，当前状态栈顶为5号状态，遇到输入终结符\$，执行r1，按照规则$S->BB$归约，将符号BB移出符号栈，状态25移出状态栈，将符号S移入符号栈。此时状态栈：0，符号栈：\$S，输入缓冲区：\$。
12. 上步为归约所以查GOTO表，当前状态栈顶为0号状态，符号栈顶为非终结符S，根据GOTO表跳转到状态1，即将1移进状态栈。此时状态栈：01，符号栈：\$S，输入缓冲区：\$。
13. 查ACTION表，当前状态栈顶为1号状态，遇到输入终结符\$，执行acc，即accept，接收成功。此时状态栈：0，符号栈：\$S，输入缓冲区：\$。


#### 1.2.3.LALR分析法
β
#### 1.2.4.二义性文法LR分析