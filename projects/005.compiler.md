# 1.resources

* [哈工大《编译原理》视频教程](https://www.bilibili.com/video/av17649289?p=7)
* [LLVM官网资料(实现一个编译器demo)](http://llvm.org/docs/tutorial/)

# 2.tools
**golang**

* goyacc: golang yacc tool
* example: https://github.com/z-rui/interp2 使用golang自带的scanner做词法分析
* example: https://github.com/golang/tools/blob/master/cmd/goyacc/testdata/expr/expr.y
* golang自带词法分析：https://github.com/golang/go/tree/master/src/text/scanner


**python**

* ply: python lex-yacc https://www.dabeaz.com/ply/ply.html. 
* example: https://www.dabeaz.com/ply/example.html
* [《python Lex Yacc 手册》](https://www.kancloud.cn/kancloud/ply/42113)

# Notes

以下笔记基于[哈工大《编译原理》视频教程](https://www.bilibili.com/video/av17649289?p=7)。

- [1.resources](#1resources)
- [2.tools](#2tools)
- [Notes](#notes)
  - [1.语法分析](#1语法分析)
    - [1.0.基本概念相关](#10基本概念相关)
      - [1.0.0.文法](#100文法)
      - [1.0.1.分析树](#101分析树)
      - [1.0.2.自顶向下](#102自顶向下)
      - [1.0.3.自底向上](#103自底向上)
      - [1.0.4.左递归](#104左递归)
      - [1.0.5.LL(k)和LR(k)](#105llk和lrk)
    - [1.1.自顶向下语法分析](#11自顶向下语法分析)
      - [1.1.1.最左推导](#111最左推导)
      - [1.1.2.最右推导](#112最右推导)
      - [1.1.3.消除左递归](#113消除左递归)
      - [1.1.4.构建预测分析表](#114构建预测分析表)
    - [1.2.自底向上语法分析](#12自底向上语法分析)
      - [1.2.1.LR分析法](#121lr分析法)
      - [1.2.2.LALR分析法](#122lalr分析法)
      - [1.2.3.二义性文法LR分析](#123二义性文法lr分析)

## 1.语法分析

### 1.0.基本概念相关
#### 1.0.0.文法
文法的形式化定义：
* $N$ 有限个非终结符的集合；
* $\Sigma$ 有限个终结符的集合；
* $P$ 有限个生产规则(产生式)的集合；
* $S$ 非终结符集合中唯一的开始符号；
  
文法被定义成一个四元组$(N, \Sigma, P, S)$，产生式的示例：

* $A -> aAb$
* $A -> ab$
* $A -> \epsilon$
  
$\epsilon$表示为空，由此可以产生出`ab`, `aabb`, `aaa..bbb`等字符串。


#### 1.0.1.分析树

以下面的文法和输入为例：
文法：
```
E-> E + E
E-> E * E
E-> (E)
E-> id
```
输入：
```
id + (id + id)
```

对应的分析树：
```
        E
       / \
      E + E
      |   /|\
      id ( E )
          /|\
        E  +  E
        |     |
        id    id
```

#### 1.0.2.自顶向下
自顶向下也就是按照从分析树的**根节点向叶节点**的方向，即从顶部向底部构造分析树。

#### 1.0.3.自底向上
与自顶向下相反，自底向上也就是按照从分析树的**叶节点向根节点**的方向，即从底部向根部构造分析树。

#### 1.0.4.左递归
左递归文法示例：
```
E -> E + T
  -> E + T + T
  -> E + T + T + T
  -> ...
```
像上面这种含有 A->A$\alpha$ 形式产生式的文法称为是直接左递归的(immediate left recursive).

若一个非终结符号（non-terminal） A 有任何直接的文法规则或者透过多个文法规则，推导出的句型（sentential form）其中最左边的符号又会出现 A ，则我们说这个非终结符号 A 是左递归的。

经过两步或者两步以上推导产生的左递归称为是间接左递归的。

#### 1.0.5.LL(k)和LR(k)
LL(k)/LR(k)
* 中第一个字母L表示对输入的扫描的方向是从左到右扫描；
* 第二个字母L最左推导，R表示反向构造出一个最右推导序列；
* (k)表示分析时向前看k个输入符号；

当k=0时，可以省略(0)直接写成LL/LR。

### 1.1.自顶向下语法分析
从分析树的根节点向叶节点方向构造分析树。

#### 1.1.1.最左推导

**原则：**总是选择每个句型中的**最左非终结符**进行替换。
例如上面的文法和输入，使用最左推导过程如下：
```
E -> E + E
  -> id + E
  -> id + (E)
  -> id + (E + E)
  -> id + (id + E)
  -> id + (id + id)
```
上面的过程从上往下叫做**最左推导**，反过来从下往上叫做**最右规约**。

**自顶向下的语法分析采用最左推导方式。**

#### 1.1.2.最右推导

**原则：**总是选择每个句型中的**最右非终结符**进行替换。
例如上面的文法和输入，使用最右推导过程如下：
```
E -> E + E
  -> E + (E)
  -> E + (E + E)
  -> E + (E + id)
  -> E + (id + id)
  -> id + id + id)
```

上面的过程从上往下叫做**最右推导**，反过来从下往上叫做**最左规约**。

在**自底向上**的分析中中，总是采用最左规约的方式，因此把**最左规约**成为**规范规约**，把**最右推导**称为**规范推导**。


#### 1.1.3.消除左递归
从前面说的左递归可以知道，左递归文法会使递归下降分析器陷入无限循环。

消除直接左递归：
* $A -> A\alpha|\beta$ (注： $\alpha$不为空，$\beta$不以$A$开头)
  
通过引入一些非终结符和空产生式。
* $A -> \beta A'$
* $A' -> \alpha A'|\epsilon$
  



消除间接左递归：

示例：
* $S -> Aa|b$
* $A -> Ac|Sd|\epsilon$

将第一条文法带入第二条得到：
* $A -> Ac|Aad|bd|\epsilon$

消除左递归：
* $A -> bdA'$
* $A' -> cA'|adA'|\epsilon$

#### 1.1.4.构建预测分析表
* FIRST(A)集：可以从非终结符A推导出的所有**串首终结符**构成的集合。
  * 示例：
    * $E->TE'$
    * $E'->+TE'|\epsilon$
    * $T->FT'$
    * $T'->*FT'|\epsilon$
    * $F->(E)|id$

  * 推导出各项非终结符的FIRST集：
    * $FIRST(E) = \{ (,  id \}$
    * $FIRST(E') = \{+, \epsilon\}$
    * $FIRST(T) = \{(, id\}$
    * $FIRST(T') = \{*, \epsilon\}$
    * $FIRST(F) = \{(, id\}$

* FOLLOW(A)集：可能在某个句型中**紧跟在非终结符A后面的终结符**a的集合。如果A是某个句型的最右符号，则将结束符"$"添加到FOLLOW(A)中。
  * 规则
    * 若A是开始符号，则$就在FOLLOW(A)中。
    * 若存在产生式$B->\alpha A\beta$，则 $FIRST(\beta)-\{\epsilon\}$ 在FOLLOW(A)中。
    * 若存在产生式$B->\alpha A\beta$，且 $\epsilon$ 在$FIRST(\beta)$中，则FOLLOW(A)包括FOLLOW(B)。
  * 示例：
    * $E->TE'$
    * $E'->+TE'|\epsilon$
    * $T->FT'$
    * $T'->*FT'|\epsilon$
    * $F->(E)|id$

  * 首先将\$加入开始符号E的FOLLOW集中，推导出各项非终结符的FOLLOW集：
    * $FOLLOW(E) = \{\$, )\}$
    * $FOLLOW(E') = \{\$, )\}$
    * $FOLLOW(T) = \{+, \$, )\}$
    * $FOLLOW(T') = \{+, \$, )\}$
    * $FOLLOW(F) = \{*, +, \$, )\}$


* SELECT(A)集：
  * |X|FIRST(X)|FOLLOW(X)|
    |---|----|----|
    |E|( id|$ )|
    |E'|+ $\epsilon$|$ )|
    |T|(, id|+ ) $|
    |T'|* $\epsilon$|+ ) $|
    |F|( id|* + ) $|
  * 得到SELECT集：
    |产生式|SELECT|
    |------|------|
    |E->TE'|( id|
    |E'->+TE'|+|
    |E'->$\epsilon$|$ )|
    |T->FT'|( id|
    |T'->*FT'|*|
    |T'->$\epsilon$|+ ) $|
    |F->(E)|(|
    |F->id|id|
    上面的文法是LL(1)文法，**同一非终结符的各个产生式的可选集互不相交**。
* 预测分析表
  |X|产生式|SELECT|
  |----|----|---|
  |E  |E->TE'|( id|
  |E'  |E'->+TE'|+|
  |  |E'->$\epsilon$|$ )|
  |T  |T->FT'|( id|
  |T'  |T'->*FT'|*|
  |F  |F->(E)|(|
  | |F->id|id|

### 1.2.自底向上语法分析
* 从分析树的叶节点向根节点方向构造分析树。

* 可以看成是从输入串规约为文法开始符号S的过程。

* **自顶向下**的语法分析采用的**最左推导**

* **自底向上**的语法分析采用的**最左规约**，即反向构造最右推导。

自底向上语法分析采用的移进-规约分析(shift-reduce parsing)。

示例：
|栈|剩余输入|动作|
|--|--|--|
|$|id + (id + id)$||
|$id|+ (id + id)$|移进|
|$E|+ (id + id)$|规约：E->id|
|$E +|(id + id)$|移进|
|$E +(|id + id)$|移进|
|$E + (id| + id)$|移进|
|$E + (E| + id)$|规约：E->id|
|$E + (E +| id)$|移进|
|$E + (E + id|)$|移进|
|$E + (E + E|)$|规约：E->id|
|$E + (E|)$|规约：E->E+E|
|$E + (E)|$|移进|
|$E + E|$|规约：E->(E)|
|$E|$|规约：E->E+E|

#### 1.2.1.LR分析法
LR文法是最大的、可以构造出相应移进-规约语法分析器的问法类。

* L：对输入从左到右扫描
* R：反向构造最右推导序列

LR(k)：预测分析时向前看k个符号。

#### 1.2.2.LALR分析法
::
#### 1.2.3.二义性文法LR分析